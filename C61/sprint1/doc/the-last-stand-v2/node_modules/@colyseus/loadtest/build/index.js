'use strict';

var path = require('path');
var util = require('util');
var blessed = require('blessed');
var minimist = require('minimist');
var logWriter = require('./logWriter.js');
var colyseus_js = require('colyseus.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var util__default = /*#__PURE__*/_interopDefaultLegacy(util);
var blessed__default = /*#__PURE__*/_interopDefaultLegacy(blessed);
var minimist__default = /*#__PURE__*/_interopDefaultLegacy(minimist);

// TODO: use "timers/promises" instead (drop Node.js v14)
const timer = {
    setTimeout(milliseconds, ...args) {
        return new Promise((resolve) => setTimeout(resolve, milliseconds, ...args));
    }
};
const argv = minimist__default['default'](process.argv.slice(2));
// const packageJson = import("../package.json");
const packageJson = { name: "@colyseus/loadtest", version: "0.14" };
function displayHelpAndExit() {
    console.log(`${packageJson.name} v${packageJson.version}

Options:
    --endpoint: WebSocket endpoint for all connections (default: ws://localhost:2567)
    --room: room handler name (you can also use --roomId instead to join by id)
    --roomId: room id (specify instead of --room)
    [--numClients]: number of connections to open (default is 1)
    [--delay]: delay to start each connection (in milliseconds)
    [--project]: specify a tsconfig.json file path
    [--reestablishAllDelay]: delay for closing and re-establishing all connections (in milliseconds)
    [--retryFailed]: delay to retry failed connections (in milliseconds)
    [--output]: specify an output file (default to loadtest.log)

Example:
    colyseus-loadtest example/bot.ts --endpoint ws://localhost:2567 --room state_handler`);
    process.exit();
}
if (argv.help) {
    displayHelpAndExit();
}
const options = {
    endpoint: argv.endpoint || `ws://localhost:2567`,
    roomName: argv.room,
    roomId: argv.roomId,
    numClients: argv.numClients || 1,
    scriptFile: argv._[0] && path__default['default'].resolve(argv._[0]),
    delay: argv.delay || 0,
    logLevel: argv.logLevel?.toLowerCase() || "all",
    reestablishAllDelay: argv.reestablishAllDelay || 0,
    retryFailed: argv.retryFailed || 0,
    output: path__default['default'].resolve(argv.output || "loadtest.log"),
};
if (!options.scriptFile) {
    console.error("❌ You must specify a script file.");
    console.error("");
    displayHelpAndExit();
}
const scriptModule = Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(options.scriptFile)); });
const connections = [];
if (!options.roomName && !options.roomId) {
    console.error("❌ You need to specify a room with either one of the '--room' or '--roomId' options.");
    console.error("");
    displayHelpAndExit();
}
if (options.output) {
    logWriter.create(options.output);
    logWriter.write(`@colyseus/loadtest\n${Object.keys(options)
        .filter(key => options[key])
        .map((key) => `${key}: ${options[key]}`).join('\n')}`);
}
const screen = blessed__default['default'].screen({ smartCSR: true });
const headerBox = blessed__default['default'].box({
    label: ` ⚔  ${packageJson.name} ${packageJson.version} ⚔  `,
    top: 0,
    left: 0,
    width: "70%",
    height: 'shrink',
    children: [
        blessed__default['default'].text({ top: 1, left: 1, tags: true, content: `{yellow-fg}endpoint:{/yellow-fg} ${options.endpoint}` }),
        blessed__default['default'].text({ top: 2, left: 1, tags: true, content: `{yellow-fg}room:{/yellow-fg} ${options.roomName ?? options.roomId}` }),
        blessed__default['default'].text({ top: 3, left: 1, tags: true, content: `{yellow-fg}serialization method:{/yellow-fg} ...` }),
        blessed__default['default'].text({ top: 4, left: 1, tags: true, content: `{yellow-fg}time elapsed:{/yellow-fg} ...` }),
    ],
    border: { type: 'line' },
    style: {
        label: { fg: 'cyan' },
        border: { fg: 'green' }
    }
});
const currentStats = {
    connected: 0,
    failed: 0,
};
const totalStats = {
    connected: 0,
    failed: 0,
    errors: 0,
};
const successfulConnectionBox = blessed__default['default'].text({ top: 2, left: 1, tags: true, content: `{yellow-fg}connected:{/yellow-fg} ${currentStats.connected}` });
const failedConnectionBox = blessed__default['default'].text({ top: 3, left: 1, tags: true, content: `{yellow-fg}failed:{/yellow-fg} ${currentStats.failed}` });
const clientsBox = blessed__default['default'].box({
    label: ' clients ',
    left: "70%",
    width: "30%",
    height: 'shrink',
    children: [
        blessed__default['default'].text({ top: 1, left: 1, tags: true, content: `{yellow-fg}numClients:{/yellow-fg} ${options.numClients}` }),
        successfulConnectionBox,
        failedConnectionBox
    ],
    border: { type: 'line' },
    tags: true,
    style: {
        label: { fg: 'cyan' },
        border: { fg: 'green' },
    }
});
const processingBox = blessed__default['default'].box({
    label: ' processing ',
    top: 6,
    left: "70%",
    width: "30%",
    height: 'shrink',
    border: { type: 'line' },
    children: [
        blessed__default['default'].text({ top: 1, left: 1, tags: true, content: `{yellow-fg}memory:{/yellow-fg} ...` }),
        blessed__default['default'].text({ top: 2, left: 1, tags: true, content: `{yellow-fg}cpu:{/yellow-fg} ...` }),
        // blessed.text({ top: 1, left: 1, content: `memory: ${process.memoryUsage().heapUsed} / ${process.memoryUsage().heapTotal}` })
    ],
    tags: true,
    style: {
        label: { fg: 'cyan' },
        border: { fg: 'green' },
    }
});
const networkingBox = blessed__default['default'].box({
    label: ' networking ',
    top: 11,
    left: "70%",
    width: "30%",
    border: { type: 'line' },
    children: [
        blessed__default['default'].text({ top: 1, left: 1, tags: true, content: `{yellow-fg}bytes received:{/yellow-fg} ...` }),
        blessed__default['default'].text({ top: 2, left: 1, tags: true, content: `{yellow-fg}bytes sent:{/yellow-fg} ...` }),
        // blessed.text({ top: 1, left: 1, content: `memory: ${process.memoryUsage().heapUsed} / ${process.memoryUsage().heapTotal}` })
    ],
    tags: true,
    style: {
        label: { fg: 'cyan' },
        border: { fg: 'green' },
    }
});
const logBox = blessed__default['default'].box({
    label: ' logs ',
    top: 7,
    width: "70%",
    padding: 1,
    border: { type: 'line' },
    tags: true,
    style: {
        label: { fg: 'cyan' },
        border: { fg: 'green' },
    },
    // scroll
    scrollable: true,
    input: true,
    alwaysScroll: true,
    scrollbar: {
        style: {
            bg: "green"
        },
        track: {
            bg: "gray"
        }
    },
    keys: true,
    vi: true,
    mouse: true
});
screen.key(['escape', 'q', 'C-c'], (ch, key) => beforeExit()); // Quit on Escape, q, or Control-C.
screen.title = "@colyseus/loadtest";
screen.append(headerBox);
screen.append(clientsBox);
screen.append(logBox);
screen.append(processingBox);
screen.append(networkingBox);
screen.render();
const log = console.log;
const error = console.error;
console.log = function (...args) {
    logBox.content = args.map(arg => util__default['default'].inspect(arg)).join(" ") + "\n" + logBox.content;
    screen.render();
};
console.warn = function (...args) {
    logBox.content = `{yellow-fg}${args.map(arg => util__default['default'].inspect(arg)).join(" ")}{/yellow-fg}\n${logBox.content}`;
    screen.render();
};
console.info = function (...args) {
    logBox.content = `{blue-fg}${args.map(arg => util__default['default'].inspect(arg)).join(" ")}{/blue-fg}\n${logBox.content}`;
    screen.render();
};
console.error = function (...args) {
    totalStats.errors++;
    logBox.content = `{red-fg}${args.map(arg => util__default['default'].inspect(arg)).join(" ")}{/red-fg}\n${logBox.content}`;
    screen.render();
};
process.on("uncaughtException", (e) => {
    console.error(e);
});
let isExiting = false;
async function beforeExit(signal, closeCode = 0) {
    log("Writing log file...");
    if (isExiting) {
        return;
    }
    else {
        isExiting = true;
    }
    const hasError = (closeCode > 0);
    await logWriter.write(`Finished. Summary:
Successful connections: ${totalStats.connected}
Failed connections: ${totalStats.failed}
Total errors: ${totalStats.errors}`, true /* closing */);
    process.exit(hasError ? 1 : 0);
}
// trap process signals
process.once('exit', (code) => beforeExit("SIGINT", code));
['SIGINT', 'SIGTERM', 'SIGUSR2'].forEach((signal) => process.once(signal, (signal) => beforeExit()));
function formatBytes(bytes) {
    if (bytes < 1024) {
        return `${bytes} b`;
    }
    else if (bytes < Math.pow(1024, 2)) {
        return `${(bytes / 1024).toFixed(2)} kb`;
    }
    else if (bytes < Math.pow(1024, 4)) {
        return `${(bytes / 1024 / 1024).toFixed(2)} MB`;
    }
}
function elapsedTime(inputSeconds) {
    const days = Math.floor(inputSeconds / (60 * 60 * 24));
    const hours = Math.floor((inputSeconds % (60 * 60 * 24)) / (60 * 60));
    const minutes = Math.floor(((inputSeconds % (60 * 60 * 24)) % (60 * 60)) / 60);
    const seconds = Math.floor(((inputSeconds % (60 * 60 * 24)) % (60 * 60)) % 60);
    let ddhhmmss = '';
    if (days > 0) {
        ddhhmmss += days + ' day ';
    }
    if (hours > 0) {
        ddhhmmss += hours + ' hour ';
    }
    if (minutes > 0) {
        ddhhmmss += minutes + ' minutes ';
    }
    if (seconds > 0) {
        ddhhmmss += seconds + ' seconds ';
    }
    return ddhhmmss || "...";
}
/**
 * Update memory / cpu usage
 */
const loadTestStartTime = Date.now();
let startTime = process.hrtime();
let startUsage = process.cpuUsage();
let bytesReceived = 0;
let bytesSent = 0;
setInterval(() => {
    /**
     * Program elapsed time
     */
    const elapsedTimeText = headerBox.children[3];
    elapsedTimeText.content = `{yellow-fg}time elapsed:{/yellow-fg} ${elapsedTime(Math.round((Date.now() - loadTestStartTime) / 1000))}`;
    /**
     * Memory / CPU Usage
     */
    const memoryText = processingBox.children[0];
    memoryText.content = `{yellow-fg}memory:{/yellow-fg} ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)} MB`;
    var elapTime = process.hrtime(startTime);
    var elapUsage = process.cpuUsage(startUsage);
    var elapTimeMS = elapTime[0] * 1000 + elapTime[1] / 1000000;
    var elapUserMS = elapUsage.user / 1000;
    var elapSystMS = elapUsage.system / 1000;
    var cpuPercent = (100 * (elapUserMS + elapSystMS) / elapTimeMS).toFixed(1);
    const cpuText = processingBox.children[1];
    cpuText.content = `{yellow-fg}cpu:{/yellow-fg} ${cpuPercent}%`;
    screen.render();
    startTime = process.hrtime();
    startUsage = process.cpuUsage();
    /**
     * Networking
     */
    const bytesReceivedBox = networkingBox.children[0];
    bytesReceivedBox.content = `{yellow-fg}bytes received:{/yellow-fg} ${formatBytes(bytesReceived)}`;
    const bytesSentBox = networkingBox.children[1];
    bytesSentBox.content = `{yellow-fg}bytes sent:{/yellow-fg} ${formatBytes(bytesSent)}`;
}, 1000);
function handleError(message) {
    if (message) {
        console.error(message);
        logWriter.write(message);
    }
    currentStats.failed++;
    totalStats.failed++;
    failedConnectionBox.content = `{red-fg}failed:{/red-fg} ${currentStats.failed}`;
    screen.render();
}
async function connect(scripting, i) {
    const tryReconnect = () => {
        if (options.retryFailed > 0) {
            setTimeout(() => connect(scripting, i), options.retryFailed);
        }
    };
    const client = new colyseus_js.Client(options.endpoint);
    const clientOptions = (typeof (scripting.requestJoinOptions) === "function")
        ? await scripting.requestJoinOptions.call(client, i)
        : {};
    (options.roomName ? client.joinOrCreate(options.roomName, clientOptions) : client.joinById(options.roomId, clientOptions)).then(room => {
        connections.push(room);
        // display serialization method in the UI
        const serializerIdText = headerBox.children[2];
        serializerIdText.content = `{yellow-fg}serialization method:{/yellow-fg} ${room.serializerId}`;
        const ws = room.connection.transport.ws;
        ws.addEventListener('message', (event) => {
            bytesReceived += new Uint8Array(event.data).length;
        });
        // overwrite original send function to trap sent bytes.
        const _send = ws.send;
        ws.send = function (data) {
            bytesSent += data.byteLength;
            _send.call(ws, data);
        };
        currentStats.connected++;
        totalStats.connected++;
        successfulConnectionBox.content = `{yellow-fg}connected:{/yellow-fg} ${currentStats.connected}`;
        screen.render();
        room.onError.once(handleError);
        room.onLeave.once((code) => {
            currentStats.connected--;
            successfulConnectionBox.content = `{yellow-fg}connected:{/yellow-fg} ${currentStats.connected}`;
            screen.render();
            if (code > 1000) {
                tryReconnect();
            }
        });
        if (scripting.onJoin) {
            scripting.onJoin.call(room);
        }
        if (scripting.onLeave) {
            room.onLeave(scripting.onLeave.bind(room));
        }
        if (scripting.onError) {
            room.onError(scripting.onError.bind(room));
        }
        if (scripting.onStateChange) {
            room.onStateChange(scripting.onStateChange.bind(room));
        }
    }).catch((err) => {
        handleError(err);
        tryReconnect();
    });
}
async function connectAll(scripting) {
    for (let i = 0; i < options.numClients; i++) {
        connect(scripting, i);
        if (options.delay > 0) {
            await timer.setTimeout(options.delay);
        }
    }
}
async function reestablishAll(scripting) {
    // drop all connections, wait for acknowledgement
    connections.map((connection) => connection.connection.close());
    // clear array
    connections.splice(0, connections.length);
    connections.length = 0;
    // connect again
    await connectAll(scripting);
}
try {
    (async () => {
        const scripting = await scriptModule;
        await connectAll(scripting);
        if (options.reestablishAllDelay > 0) {
            while (true) {
                // wait for delay
                await timer.setTimeout(options.reestablishAllDelay);
                await reestablishAll(scripting);
            }
        }
    })();
}
catch (e) {
    error(e.stack);
}
//# sourceMappingURL=index.js.map
